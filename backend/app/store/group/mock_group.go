// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package group

import (
	"github.com/yaattc/automatic-time-table-creation/backend/app/store"
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//     func TestSomethingThatUsesInterface(t *testing.T) {
//
//         // make and configure a mocked Interface
//         mockedInterface := &InterfaceMock{
//             AddGroupFunc: func(groupID string, name string) (string, error) {
// 	               panic("mock out the AddGroup method")
//             },
//             DeleteGroupFunc: func(id string) error {
// 	               panic("mock out the DeleteGroup method")
//             },
//             ListGroupsFunc: func() ([]store.Group, error) {
// 	               panic("mock out the ListGroups method")
//             },
//         }
//
//         // use mockedInterface in code that requires Interface
//         // and then make assertions.
//
//     }
type InterfaceMock struct {
	// AddGroupFunc mocks the AddGroup method.
	AddGroupFunc func(groupID string, name string) (string, error)

	// DeleteGroupFunc mocks the DeleteGroup method.
	DeleteGroupFunc func(id string) error

	// ListGroupsFunc mocks the ListGroups method.
	ListGroupsFunc func() ([]store.Group, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddGroup holds details about calls to the AddGroup method.
		AddGroup []struct {
			// GroupID is the groupID argument value.
			GroupID string
			// Name is the name argument value.
			Name string
		}
		// DeleteGroup holds details about calls to the DeleteGroup method.
		DeleteGroup []struct {
			// ID is the id argument value.
			ID string
		}
		// ListGroups holds details about calls to the ListGroups method.
		ListGroups []struct {
		}
	}
	lockAddGroup    sync.RWMutex
	lockDeleteGroup sync.RWMutex
	lockListGroups  sync.RWMutex
}

// AddGroup calls AddGroupFunc.
func (mock *InterfaceMock) AddGroup(groupID string, name string) (string, error) {
	if mock.AddGroupFunc == nil {
		panic("InterfaceMock.AddGroupFunc: method is nil but Interface.AddGroup was just called")
	}
	callInfo := struct {
		GroupID string
		Name    string
	}{
		GroupID: groupID,
		Name:    name,
	}
	mock.lockAddGroup.Lock()
	mock.calls.AddGroup = append(mock.calls.AddGroup, callInfo)
	mock.lockAddGroup.Unlock()
	return mock.AddGroupFunc(groupID, name)
}

// AddGroupCalls gets all the calls that were made to AddGroup.
// Check the length with:
//     len(mockedInterface.AddGroupCalls())
func (mock *InterfaceMock) AddGroupCalls() []struct {
	GroupID string
	Name    string
} {
	var calls []struct {
		GroupID string
		Name    string
	}
	mock.lockAddGroup.RLock()
	calls = mock.calls.AddGroup
	mock.lockAddGroup.RUnlock()
	return calls
}

// DeleteGroup calls DeleteGroupFunc.
func (mock *InterfaceMock) DeleteGroup(id string) error {
	if mock.DeleteGroupFunc == nil {
		panic("InterfaceMock.DeleteGroupFunc: method is nil but Interface.DeleteGroup was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteGroup.Lock()
	mock.calls.DeleteGroup = append(mock.calls.DeleteGroup, callInfo)
	mock.lockDeleteGroup.Unlock()
	return mock.DeleteGroupFunc(id)
}

// DeleteGroupCalls gets all the calls that were made to DeleteGroup.
// Check the length with:
//     len(mockedInterface.DeleteGroupCalls())
func (mock *InterfaceMock) DeleteGroupCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteGroup.RLock()
	calls = mock.calls.DeleteGroup
	mock.lockDeleteGroup.RUnlock()
	return calls
}

// ListGroups calls ListGroupsFunc.
func (mock *InterfaceMock) ListGroups() ([]store.Group, error) {
	if mock.ListGroupsFunc == nil {
		panic("InterfaceMock.ListGroupsFunc: method is nil but Interface.ListGroups was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListGroups.Lock()
	mock.calls.ListGroups = append(mock.calls.ListGroups, callInfo)
	mock.lockListGroups.Unlock()
	return mock.ListGroupsFunc()
}

// ListGroupsCalls gets all the calls that were made to ListGroups.
// Check the length with:
//     len(mockedInterface.ListGroupsCalls())
func (mock *InterfaceMock) ListGroupsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListGroups.RLock()
	calls = mock.calls.ListGroups
	mock.lockListGroups.RUnlock()
	return calls
}
