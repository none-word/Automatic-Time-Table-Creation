// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package uni

import (
	"github.com/yaattc/automatic-time-table-creation/backend/app/store"
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//     func TestSomethingThatUsesInterface(t *testing.T) {
//
//         // make and configure a mocked Interface
//         mockedInterface := &InterfaceMock{
//             AddGroupFunc: func(g store.Group) (string, error) {
// 	               panic("mock out the AddGroup method")
//             },
//             AddStudyYearFunc: func(sy store.StudyYear) (string, error) {
// 	               panic("mock out the AddStudyYear method")
//             },
//             DeleteGroupFunc: func(id string) error {
// 	               panic("mock out the DeleteGroup method")
//             },
//             DeleteStudyYearFunc: func(studyYearID string) error {
// 	               panic("mock out the DeleteStudyYear method")
//             },
//             ListGroupsFunc: func() ([]store.Group, error) {
// 	               panic("mock out the ListGroups method")
//             },
//         }
//
//         // use mockedInterface in code that requires Interface
//         // and then make assertions.
//
//     }
type InterfaceMock struct {
	// AddGroupFunc mocks the AddGroup method.
	AddGroupFunc func(g store.Group) (string, error)

	// AddStudyYearFunc mocks the AddStudyYear method.
	AddStudyYearFunc func(sy store.StudyYear) (string, error)

	// DeleteGroupFunc mocks the DeleteGroup method.
	DeleteGroupFunc func(id string) error

	// DeleteStudyYearFunc mocks the DeleteStudyYear method.
	DeleteStudyYearFunc func(studyYearID string) error

	// ListGroupsFunc mocks the ListGroups method.
	ListGroupsFunc func() ([]store.Group, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddGroup holds details about calls to the AddGroup method.
		AddGroup []struct {
			// G is the g argument value.
			G store.Group
		}
		// AddStudyYear holds details about calls to the AddStudyYear method.
		AddStudyYear []struct {
			// Sy is the sy argument value.
			Sy store.StudyYear
		}
		// DeleteGroup holds details about calls to the DeleteGroup method.
		DeleteGroup []struct {
			// ID is the id argument value.
			ID string
		}
		// DeleteStudyYear holds details about calls to the DeleteStudyYear method.
		DeleteStudyYear []struct {
			// StudyYearID is the studyYearID argument value.
			StudyYearID string
		}
		// ListGroups holds details about calls to the ListGroups method.
		ListGroups []struct {
		}
	}
	lockAddGroup        sync.RWMutex
	lockAddStudyYear    sync.RWMutex
	lockDeleteGroup     sync.RWMutex
	lockDeleteStudyYear sync.RWMutex
	lockListGroups      sync.RWMutex
}

// AddGroup calls AddGroupFunc.
func (mock *InterfaceMock) AddGroup(g store.Group) (string, error) {
	if mock.AddGroupFunc == nil {
		panic("InterfaceMock.AddGroupFunc: method is nil but Interface.AddGroup was just called")
	}
	callInfo := struct {
		G store.Group
	}{
		G: g,
	}
	mock.lockAddGroup.Lock()
	mock.calls.AddGroup = append(mock.calls.AddGroup, callInfo)
	mock.lockAddGroup.Unlock()
	return mock.AddGroupFunc(g)
}

// AddGroupCalls gets all the calls that were made to AddGroup.
// Check the length with:
//     len(mockedInterface.AddGroupCalls())
func (mock *InterfaceMock) AddGroupCalls() []struct {
	G store.Group
} {
	var calls []struct {
		G store.Group
	}
	mock.lockAddGroup.RLock()
	calls = mock.calls.AddGroup
	mock.lockAddGroup.RUnlock()
	return calls
}

// AddStudyYear calls AddStudyYearFunc.
func (mock *InterfaceMock) AddStudyYear(sy store.StudyYear) (string, error) {
	if mock.AddStudyYearFunc == nil {
		panic("InterfaceMock.AddStudyYearFunc: method is nil but Interface.AddStudyYear was just called")
	}
	callInfo := struct {
		Sy store.StudyYear
	}{
		Sy: sy,
	}
	mock.lockAddStudyYear.Lock()
	mock.calls.AddStudyYear = append(mock.calls.AddStudyYear, callInfo)
	mock.lockAddStudyYear.Unlock()
	return mock.AddStudyYearFunc(sy)
}

// AddStudyYearCalls gets all the calls that were made to AddStudyYear.
// Check the length with:
//     len(mockedInterface.AddStudyYearCalls())
func (mock *InterfaceMock) AddStudyYearCalls() []struct {
	Sy store.StudyYear
} {
	var calls []struct {
		Sy store.StudyYear
	}
	mock.lockAddStudyYear.RLock()
	calls = mock.calls.AddStudyYear
	mock.lockAddStudyYear.RUnlock()
	return calls
}

// DeleteGroup calls DeleteGroupFunc.
func (mock *InterfaceMock) DeleteGroup(id string) error {
	if mock.DeleteGroupFunc == nil {
		panic("InterfaceMock.DeleteGroupFunc: method is nil but Interface.DeleteGroup was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteGroup.Lock()
	mock.calls.DeleteGroup = append(mock.calls.DeleteGroup, callInfo)
	mock.lockDeleteGroup.Unlock()
	return mock.DeleteGroupFunc(id)
}

// DeleteGroupCalls gets all the calls that were made to DeleteGroup.
// Check the length with:
//     len(mockedInterface.DeleteGroupCalls())
func (mock *InterfaceMock) DeleteGroupCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteGroup.RLock()
	calls = mock.calls.DeleteGroup
	mock.lockDeleteGroup.RUnlock()
	return calls
}

// DeleteStudyYear calls DeleteStudyYearFunc.
func (mock *InterfaceMock) DeleteStudyYear(studyYearID string) error {
	if mock.DeleteStudyYearFunc == nil {
		panic("InterfaceMock.DeleteStudyYearFunc: method is nil but Interface.DeleteStudyYear was just called")
	}
	callInfo := struct {
		StudyYearID string
	}{
		StudyYearID: studyYearID,
	}
	mock.lockDeleteStudyYear.Lock()
	mock.calls.DeleteStudyYear = append(mock.calls.DeleteStudyYear, callInfo)
	mock.lockDeleteStudyYear.Unlock()
	return mock.DeleteStudyYearFunc(studyYearID)
}

// DeleteStudyYearCalls gets all the calls that were made to DeleteStudyYear.
// Check the length with:
//     len(mockedInterface.DeleteStudyYearCalls())
func (mock *InterfaceMock) DeleteStudyYearCalls() []struct {
	StudyYearID string
} {
	var calls []struct {
		StudyYearID string
	}
	mock.lockDeleteStudyYear.RLock()
	calls = mock.calls.DeleteStudyYear
	mock.lockDeleteStudyYear.RUnlock()
	return calls
}

// ListGroups calls ListGroupsFunc.
func (mock *InterfaceMock) ListGroups() ([]store.Group, error) {
	if mock.ListGroupsFunc == nil {
		panic("InterfaceMock.ListGroupsFunc: method is nil but Interface.ListGroups was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListGroups.Lock()
	mock.calls.ListGroups = append(mock.calls.ListGroups, callInfo)
	mock.lockListGroups.Unlock()
	return mock.ListGroupsFunc()
}

// ListGroupsCalls gets all the calls that were made to ListGroups.
// Check the length with:
//     len(mockedInterface.ListGroupsCalls())
func (mock *InterfaceMock) ListGroupsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListGroups.RLock()
	calls = mock.calls.ListGroups
	mock.lockListGroups.RUnlock()
	return calls
}
