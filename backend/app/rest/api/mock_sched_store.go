// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package api

import (
	"github.com/yaattc/automatic-time-table-creation/backend/app/store"
	"sync"
	"time"
)

// Ensure, that schedStoreMock does implement schedStore.
// If this is not the case, regenerate this file with moq.
var _ schedStore = &schedStoreMock{}

// schedStoreMock is a mock implementation of schedStore.
//
//     func TestSomethingThatUsesschedStore(t *testing.T) {
//
//         // make and configure a mocked schedStore
//         mockedschedStore := &schedStoreMock{
//             ListClassesFunc: func(from time.Time, till time.Time, groupID string) ([]store.Class, error) {
// 	               panic("mock out the ListClasses method")
//             },
//             ListTimeSlotsFunc: func() ([]store.TimeSlot, error) {
// 	               panic("mock out the ListTimeSlots method")
//             },
//         }
//
//         // use mockedschedStore in code that requires schedStore
//         // and then make assertions.
//
//     }
type schedStoreMock struct {
	// ListClassesFunc mocks the ListClasses method.
	ListClassesFunc func(from time.Time, till time.Time, groupID string) ([]store.Class, error)

	// ListTimeSlotsFunc mocks the ListTimeSlots method.
	ListTimeSlotsFunc func() ([]store.TimeSlot, error)

	// calls tracks calls to the methods.
	calls struct {
		// ListClasses holds details about calls to the ListClasses method.
		ListClasses []struct {
			// From is the from argument value.
			From time.Time
			// Till is the till argument value.
			Till time.Time
			// GroupID is the groupID argument value.
			GroupID string
		}
		// ListTimeSlots holds details about calls to the ListTimeSlots method.
		ListTimeSlots []struct {
		}
	}
	lockListClasses   sync.RWMutex
	lockListTimeSlots sync.RWMutex
}

// ListClasses calls ListClassesFunc.
func (mock *schedStoreMock) ListClasses(from time.Time, till time.Time, groupID string) ([]store.Class, error) {
	if mock.ListClassesFunc == nil {
		panic("schedStoreMock.ListClassesFunc: method is nil but schedStore.ListClasses was just called")
	}
	callInfo := struct {
		From    time.Time
		Till    time.Time
		GroupID string
	}{
		From:    from,
		Till:    till,
		GroupID: groupID,
	}
	mock.lockListClasses.Lock()
	mock.calls.ListClasses = append(mock.calls.ListClasses, callInfo)
	mock.lockListClasses.Unlock()
	return mock.ListClassesFunc(from, till, groupID)
}

// ListClassesCalls gets all the calls that were made to ListClasses.
// Check the length with:
//     len(mockedschedStore.ListClassesCalls())
func (mock *schedStoreMock) ListClassesCalls() []struct {
	From    time.Time
	Till    time.Time
	GroupID string
} {
	var calls []struct {
		From    time.Time
		Till    time.Time
		GroupID string
	}
	mock.lockListClasses.RLock()
	calls = mock.calls.ListClasses
	mock.lockListClasses.RUnlock()
	return calls
}

// ListTimeSlots calls ListTimeSlotsFunc.
func (mock *schedStoreMock) ListTimeSlots() ([]store.TimeSlot, error) {
	if mock.ListTimeSlotsFunc == nil {
		panic("schedStoreMock.ListTimeSlotsFunc: method is nil but schedStore.ListTimeSlots was just called")
	}
	callInfo := struct {
	}{}
	mock.lockListTimeSlots.Lock()
	mock.calls.ListTimeSlots = append(mock.calls.ListTimeSlots, callInfo)
	mock.lockListTimeSlots.Unlock()
	return mock.ListTimeSlotsFunc()
}

// ListTimeSlotsCalls gets all the calls that were made to ListTimeSlots.
// Check the length with:
//     len(mockedschedStore.ListTimeSlotsCalls())
func (mock *schedStoreMock) ListTimeSlotsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockListTimeSlots.RLock()
	calls = mock.calls.ListTimeSlots
	mock.lockListTimeSlots.RUnlock()
	return calls
}
